// <auto-generated/>

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using OpenAI.Internal.Models;

namespace OpenAI.Internal
{
    // Data plane generated sub-client.
    /// <summary> The Runs sub-client. </summary>
    internal partial class Runs
    {
        private const string AuthorizationHeader = "Authorization";
        private readonly ApiKeyCredential _credential;
        private const string AuthorizationApiKeyPrefix = "Bearer";
        private readonly ClientPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual ClientPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Runs for mocking. </summary>
        protected Runs()
        {
        }

        /// <summary> Initializes a new instance of Runs. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="credential"> The key credential to copy. </param>
        /// <param name="endpoint"> OpenAI Endpoint. </param>
        internal Runs(ClientPipeline pipeline, ApiKeyCredential credential, Uri endpoint)
        {
            _pipeline = pipeline;
            _credential = credential;
            _endpoint = endpoint;
        }

        /// <summary> Create a thread and run it in one request. </summary>
        /// <param name="threadAndRun"> The <see cref="CreateThreadAndRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadAndRun"/> is null. </exception>
        public virtual async Task<ClientResult<RunObject>> CreateThreadAndRunAsync(CreateThreadAndRunRequest threadAndRun)
        {
            Argument.AssertNotNull(threadAndRun, nameof(threadAndRun));

            using BinaryContent content = BinaryContent.Create(threadAndRun);
            ClientResult result = await CreateThreadAndRunAsync(content, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a thread and run it in one request. </summary>
        /// <param name="threadAndRun"> The <see cref="CreateThreadAndRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadAndRun"/> is null. </exception>
        public virtual ClientResult<RunObject> CreateThreadAndRun(CreateThreadAndRunRequest threadAndRun)
        {
            Argument.AssertNotNull(threadAndRun, nameof(threadAndRun));

            using BinaryContent content = BinaryContent.Create(threadAndRun);
            ClientResult result = CreateThreadAndRun(content, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a thread and run it in one request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateThreadAndRunAsync(CreateThreadAndRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateThreadAndRunAsync(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CreateThreadAndRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateThreadAndRunRequest(content, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a thread and run it in one request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateThreadAndRun(CreateThreadAndRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateThreadAndRun(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CreateThreadAndRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateThreadAndRunRequest(content, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a run. </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="run"> The <see cref="CreateRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunObject>> CreateRunAsync(string threadId, CreateRunRequest run)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNull(run, nameof(run));

            using BinaryContent content = BinaryContent.Create(run);
            ClientResult result = await CreateRunAsync(threadId, content, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a run. </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="run"> The <see cref="CreateRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunObject> CreateRun(string threadId, CreateRunRequest run)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNull(run, nameof(run));

            using BinaryContent content = BinaryContent.Create(run);
            ClientResult result = CreateRun(threadId, content, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateRunAsync(string,CreateRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateRunAsync(string threadId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CreateRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateRunRequest(threadId, content, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateRun(string,CreateRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateRun(string threadId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CreateRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateRunRequest(threadId, content, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of runs belonging to a thread. </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<ListRunsResponse>> GetRunsAsync(string threadId, int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));

            ClientResult result = await GetRunsAsync(threadId, limit, order?.ToString(), after, before, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(ListRunsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of runs belonging to a thread. </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<ListRunsResponse> GetRuns(string threadId, int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));

            ClientResult result = GetRuns(threadId, limit, order?.ToString(), after, before, DefaultRequestContext);
            return ClientResult.FromValue(ListRunsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of runs belonging to a thread.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunsAsync(string,int?,ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetRunsAsync(string threadId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRuns"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunsRequest(threadId, limit, order, after, before, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of runs belonging to a thread.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRuns(string,int?,ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetRuns(string threadId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRuns"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunsRequest(threadId, limit, order, after, before, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunObject>> GetRunAsync(string threadId, string runId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = await GetRunAsync(threadId, runId, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunObject> GetRun(string threadId, string runId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = GetRun(threadId, runId, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetRunAsync(string threadId, string runId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunRequest(threadId, runId, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRun(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetRun(string threadId, string runId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunRequest(threadId, runId, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Modifies a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="run"> The <see cref="ModifyRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunObject>> ModifyRunAsync(string threadId, string runId, ModifyRunRequest run)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(run, nameof(run));

            using BinaryContent content = BinaryContent.Create(run);
            ClientResult result = await ModifyRunAsync(threadId, runId, content, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Modifies a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="run"> The <see cref="ModifyRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunObject> ModifyRun(string threadId, string runId, ModifyRunRequest run)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(run, nameof(run));

            using BinaryContent content = BinaryContent.Create(run);
            ClientResult result = ModifyRun(threadId, runId, content, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Modifies a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyRunAsync(string,string,ModifyRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> ModifyRunAsync(string threadId, string runId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.ModifyRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateModifyRunRequest(threadId, runId, content, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Modifies a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyRun(string,string,ModifyRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult ModifyRun(string threadId, string runId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.ModifyRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateModifyRunRequest(threadId, runId, content, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancels a run that is `in_progress`. </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunObject>> CancelRunAsync(string threadId, string runId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = await CancelRunAsync(threadId, runId, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Cancels a run that is `in_progress`. </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunObject> CancelRun(string threadId, string runId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = CancelRun(threadId, runId, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Cancels a run that is `in_progress`.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelRunAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CancelRunAsync(string threadId, string runId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CancelRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelRunRequest(threadId, runId, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Cancels a run that is `in_progress`.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelRun(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CancelRun(string threadId, string runId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.CancelRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelRunRequest(threadId, runId, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="submitToolOutputsRun"> The <see cref="SubmitToolOutputsRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="submitToolOutputsRun"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunObject>> SubmitToolOuputsToRunAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRun)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(submitToolOutputsRun, nameof(submitToolOutputsRun));

            using BinaryContent content = BinaryContent.Create(submitToolOutputsRun);
            ClientResult result = await SubmitToolOuputsToRunAsync(threadId, runId, content, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="submitToolOutputsRun"> The <see cref="SubmitToolOutputsRunRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="submitToolOutputsRun"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunObject> SubmitToolOuputsToRun(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRun)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(submitToolOutputsRun, nameof(submitToolOutputsRun));

            using BinaryContent content = BinaryContent.Create(submitToolOutputsRun);
            ClientResult result = SubmitToolOuputsToRun(threadId, runId, content, DefaultRequestContext);
            return ClientResult.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SubmitToolOuputsToRunAsync(string,string,SubmitToolOutputsRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> SubmitToolOuputsToRunAsync(string threadId, string runId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.SubmitToolOuputsToRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateSubmitToolOuputsToRunRequest(threadId, runId, content, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SubmitToolOuputsToRun(string,string,SubmitToolOutputsRunRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult SubmitToolOuputsToRun(string threadId, string runId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNull(content, nameof(content));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.SubmitToolOuputsToRun"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateSubmitToolOuputsToRunRequest(threadId, runId, content, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of run steps belonging to a run. </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<ListRunStepsResponse>> GetRunStepsAsync(string threadId, string runId, int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = await GetRunStepsAsync(threadId, runId, limit, order?.ToString(), after, before, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(ListRunStepsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of run steps belonging to a run. </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<ListRunStepsResponse> GetRunSteps(string threadId, string runId, int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            ClientResult result = GetRunSteps(threadId, runId, limit, order?.ToString(), after, before, DefaultRequestContext);
            return ClientResult.FromValue(ListRunStepsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of run steps belonging to a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStepsAsync(string,string,int?,ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetRunStepsAsync(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunSteps"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepsRequest(threadId, runId, limit, order, after, before, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of run steps belonging to a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunSteps(string,string,int?,ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetRunSteps(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunSteps"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepsRequest(threadId, runId, limit, order, after, before, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves a run step. </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ClientResult<RunStepObject>> GetRunStepAsync(string threadId, string runId, string stepId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNullOrEmpty(stepId, nameof(stepId));

            ClientResult result = await GetRunStepAsync(threadId, runId, stepId, DefaultRequestContext).ConfigureAwait(false);
            return ClientResult.FromValue(RunStepObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a run step. </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ClientResult<RunStepObject> GetRunStep(string threadId, string runId, string stepId)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNullOrEmpty(stepId, nameof(stepId));

            ClientResult result = GetRunStep(threadId, runId, stepId, DefaultRequestContext);
            return ClientResult.FromValue(RunStepObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run step.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStepAsync(string,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetRunStepAsync(string threadId, string runId, string stepId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNullOrEmpty(stepId, nameof(stepId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunStep"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepRequest(threadId, runId, stepId, options);
                return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run step.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStep(string,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetRunStep(string threadId, string runId, string stepId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(threadId, nameof(threadId));
            Argument.AssertNotNullOrEmpty(runId, nameof(runId));
            Argument.AssertNotNullOrEmpty(stepId, nameof(stepId));

            options ??= new RequestOptions();
            // using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunStep"\);
            // scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepRequest(threadId, runId, stepId, options);
                return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
            }
            catch (Exception e)
            {
                // scope.Failed(e);
                throw;
            }
        }

        internal PipelineMessage CreateCreateThreadAndRunRequest(BinaryContent content, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/runs");
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateCreateRunRequest(string threadId, BinaryContent content, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs");
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateGetRunsRequest(string threadId, int? limit, string order, string after, string before, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "GET";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs");
            if (limit != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&limit={limit.Value}";
                }
                else
                {
                    uriBuilder.Query = $"limit={limit.Value}";
                }
            }
            if (order != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&order={order}";
                }
                else
                {
                    uriBuilder.Query = $"order={order}";
                }
            }
            if (after != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&after={after}";
                }
                else
                {
                    uriBuilder.Query = $"after={after}";
                }
            }
            if (before != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&before={before}";
                }
                else
                {
                    uriBuilder.Query = $"before={before}";
                }
            }
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetRunRequest(string threadId, string runId, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "GET";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateModifyRunRequest(string threadId, string runId, BinaryContent content, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateCancelRunRequest(string threadId, string runId, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            path.Append("/cancel");
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateSubmitToolOuputsToRunRequest(string threadId, string runId, BinaryContent content, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "POST";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            path.Append("/submit_tool_outputs");
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            message.Apply(options);
            return message;
        }

        internal PipelineMessage CreateGetRunStepsRequest(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "GET";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            path.Append("/steps");
            if (limit != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&limit={limit.Value}";
                }
                else
                {
                    uriBuilder.Query = $"limit={limit.Value}";
                }
            }
            if (order != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&order={order}";
                }
                else
                {
                    uriBuilder.Query = $"order={order}";
                }
            }
            if (after != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&after={after}";
                }
                else
                {
                    uriBuilder.Query = $"after={after}";
                }
            }
            if (before != null)
            {
                if (uriBuilder.Query != null && uriBuilder.Query.Length > 1)
                {
                    uriBuilder.Query += $"&before={before}";
                }
                else
                {
                    uriBuilder.Query = $"before={before}";
                }
            }
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetRunStepRequest(string threadId, string runId, string stepId, RequestOptions options)
        {
            PipelineMessage message = _pipeline.CreateMessage();
            message.ResponseClassifier = ResponseErrorClassifier200;
            PipelineRequest request = message.Request;
            request.Method = "GET";
            UriBuilder uriBuilder = new(_endpoint.ToString());
            StringBuilder path = new();
            path.Append("/threads/");
            path.Append(threadId);
            path.Append("/runs/");
            path.Append(runId);
            path.Append("/steps/");
            path.Append(stepId);
            uriBuilder.Path += path.ToString();
            request.Uri = uriBuilder.Uri;
            request.Headers.Set("Accept", "application/json");
            return message;
        }

        private static RequestOptions DefaultRequestContext = new RequestOptions();

        private static PipelineMessageClassifier _responseErrorClassifier200;
        private static PipelineMessageClassifier ResponseErrorClassifier200 => _responseErrorClassifier200 ??= PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });
    }
}
