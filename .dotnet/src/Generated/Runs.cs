// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Internal;
using System.ClientModel.Primitives;
using System.ClientModel.Primitives.Pipeline;
using System.Threading;
using System.Threading.Tasks;
using OpenAI.Models;

namespace OpenAI
{
    // Data plane generated sub-client.
    /// <summary> The Runs sub-client. </summary>
    public partial class Runs
    {
        private const string AuthorizationHeader = "Authorization";
        private readonly KeyCredential _keyCredential;
        private const string AuthorizationApiKeyPrefix = "Bearer";
        private readonly MessagePipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal TelemetrySource ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual MessagePipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Runs for mocking. </summary>
        protected Runs()
        {
        }

        /// <summary> Initializes a new instance of Runs. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="endpoint"> OpenAI Endpoint. </param>
        internal Runs(TelemetrySource clientDiagnostics, MessagePipeline pipeline, KeyCredential keyCredential, Uri endpoint)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _endpoint = endpoint;
        }

        /// <summary> Create a thread and run it in one request. </summary>
        /// <param name="threadAndRun"> The <see cref="CreateThreadAndRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadAndRun"/> is null. </exception>
        public virtual async Task<Result<RunObject>> CreateThreadAndRunAsync(CreateThreadAndRunRequest threadAndRun, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(threadAndRun, nameof(threadAndRun));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = threadAndRun.ToRequestBody();
            Result result = await CreateThreadAndRunAsync(content, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a thread and run it in one request. </summary>
        /// <param name="threadAndRun"> The <see cref="CreateThreadAndRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadAndRun"/> is null. </exception>
        public virtual Result<RunObject> CreateThreadAndRun(CreateThreadAndRunRequest threadAndRun, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNull(threadAndRun, nameof(threadAndRun));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = threadAndRun.ToRequestBody();
            Result result = CreateThreadAndRun(content, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a thread and run it in one request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateThreadAndRunAsync(CreateThreadAndRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateThreadAndRunAsync(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CreateThreadAndRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateThreadAndRunRequest(content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a thread and run it in one request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateThreadAndRun(CreateThreadAndRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateThreadAndRun(RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CreateThreadAndRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateThreadAndRunRequest(content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a run. </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="run"> The <see cref="CreateRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunObject>> CreateRunAsync(string threadId, CreateRunRequest run, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNull(run, nameof(run));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = run.ToRequestBody();
            Result result = await CreateRunAsync(threadId, content, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a run. </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="run"> The <see cref="CreateRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunObject> CreateRun(string threadId, CreateRunRequest run, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNull(run, nameof(run));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = run.ToRequestBody();
            Result result = CreateRun(threadId, content, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateRunAsync(string,CreateRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CreateRunAsync(string threadId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CreateRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateRunRequest(threadId, content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateRun(string,CreateRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to run. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CreateRun(string threadId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CreateRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCreateRunRequest(threadId, content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of runs belonging to a thread. </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<ListRunsResponse>> GetRunsAsync(string threadId, int? limit = null, ListOrder? order = null, string after = null, string before = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetRunsAsync(threadId, limit, order?.ToString(), after, before, context).ConfigureAwait(false);
            return Result.FromValue(ListRunsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of runs belonging to a thread. </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<ListRunsResponse> GetRuns(string threadId, int? limit = null, ListOrder? order = null, string after = null, string before = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetRuns(threadId, limit, order?.ToString(), after, before, context);
            return Result.FromValue(ListRunsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of runs belonging to a thread.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunsAsync(string,int?,ListOrder?,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetRunsAsync(string threadId, int? limit, string order, string after, string before, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRuns");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunsRequest(threadId, limit, order, after, before, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of runs belonging to a thread.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRuns(string,int?,ListOrder?,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run belongs to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetRuns(string threadId, int? limit, string order, string after, string before, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRuns");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunsRequest(threadId, limit, order, after, before, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunObject>> GetRunAsync(string threadId, string runId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetRunAsync(threadId, runId, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunObject> GetRun(string threadId, string runId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetRun(threadId, runId, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetRunAsync(string threadId, string runId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunRequest(threadId, runId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRun(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetRun(string threadId, string runId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunRequest(threadId, runId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Modifies a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="run"> The <see cref="ModifyRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunObject>> ModifyRunAsync(string threadId, string runId, ModifyRunRequest run, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(run, nameof(run));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = run.ToRequestBody();
            Result result = await ModifyRunAsync(threadId, runId, content, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Modifies a run. </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="run"> The <see cref="ModifyRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="run"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunObject> ModifyRun(string threadId, string runId, ModifyRunRequest run, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(run, nameof(run));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = run.ToRequestBody();
            Result result = ModifyRun(threadId, runId, content, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Modifies a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyRunAsync(string,string,ModifyRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> ModifyRunAsync(string threadId, string runId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.ModifyRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateModifyRunRequest(threadId, runId, content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Modifies a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyRun(string,string,ModifyRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) that was run. </param>
        /// <param name="runId"> The ID of the run to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result ModifyRun(string threadId, string runId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.ModifyRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateModifyRunRequest(threadId, runId, content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancels a run that is `in_progress`. </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunObject>> CancelRunAsync(string threadId, string runId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await CancelRunAsync(threadId, runId, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Cancels a run that is `in_progress`. </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunObject> CancelRun(string threadId, string runId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = CancelRun(threadId, runId, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Cancels a run that is `in_progress`.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelRunAsync(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> CancelRunAsync(string threadId, string runId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CancelRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelRunRequest(threadId, runId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Cancels a run that is `in_progress`.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelRun(string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which this run belongs. </param>
        /// <param name="runId"> The ID of the run to cancel. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result CancelRun(string threadId, string runId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.CancelRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateCancelRunRequest(threadId, runId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="submitToolOutputsRun"> The <see cref="SubmitToolOutputsRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="submitToolOutputsRun"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunObject>> SubmitToolOuputsToRunAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRun, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(submitToolOutputsRun, nameof(submitToolOutputsRun));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = submitToolOutputsRun.ToRequestBody();
            Result result = await SubmitToolOuputsToRunAsync(threadId, runId, content, context).ConfigureAwait(false);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="submitToolOutputsRun"> The <see cref="SubmitToolOutputsRunRequest"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="submitToolOutputsRun"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunObject> SubmitToolOuputsToRun(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRun, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(submitToolOutputsRun, nameof(submitToolOutputsRun));

            RequestOptions context = FromCancellationToken(cancellationToken);
            using RequestBody content = submitToolOutputsRun.ToRequestBody();
            Result result = SubmitToolOuputsToRun(threadId, runId, content, context);
            return Result.FromValue(RunObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SubmitToolOuputsToRunAsync(string,string,SubmitToolOutputsRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> SubmitToolOuputsToRunAsync(string threadId, string runId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.SubmitToolOuputsToRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateSubmitToolOuputsToRunRequest(threadId, runId, content, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] When a run has the `status: "requires_action"` and `required_action.type` is
        /// `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once
        /// they're all completed. All outputs must be submitted in a single request.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="SubmitToolOuputsToRun(string,string,SubmitToolOutputsRunRequest,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the [thread](/docs/api-reference/threads) to which this run belongs. </param>
        /// <param name="runId"> The ID of the run that requires the tool output submission. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result SubmitToolOuputsToRun(string threadId, string runId, RequestBody content, RequestOptions context = null)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateSpan("Runs.SubmitToolOuputsToRun");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateSubmitToolOuputsToRunRequest(threadId, runId, content, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns a list of run steps belonging to a run. </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<ListRunStepsResponse>> GetRunStepsAsync(string threadId, string runId, int? limit = null, ListOrder? order = null, string after = null, string before = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetRunStepsAsync(threadId, runId, limit, order?.ToString(), after, before, context).ConfigureAwait(false);
            return Result.FromValue(ListRunStepsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of run steps belonging to a run. </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<ListRunStepsResponse> GetRunSteps(string threadId, string runId, int? limit = null, ListOrder? order = null, string after = null, string before = null, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetRunSteps(threadId, runId, limit, order?.ToString(), after, before, context);
            return Result.FromValue(ListRunStepsResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of run steps belonging to a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStepsAsync(string,string,int?,ListOrder?,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetRunStepsAsync(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunSteps");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepsRequest(threadId, runId, limit, order, after, before, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns a list of run steps belonging to a run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunSteps(string,string,int?,ListOrder?,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread the run and run steps belong to. </param>
        /// <param name="runId"> The ID of the run the run steps belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/> or <paramref name="runId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/> or <paramref name="runId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetRunSteps(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunSteps");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepsRequest(threadId, runId, limit, order, after, before, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves a run step. </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Result<RunStepObject>> GetRunStepAsync(string threadId, string runId, string stepId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNullOrEmpty(stepId, nameof(stepId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = await GetRunStepAsync(threadId, runId, stepId, context).ConfigureAwait(false);
            return Result.FromValue(RunStepObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a run step. </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Result<RunStepObject> GetRunStep(string threadId, string runId, string stepId, CancellationToken cancellationToken = default)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNullOrEmpty(stepId, nameof(stepId));

            RequestOptions context = FromCancellationToken(cancellationToken);
            Result result = GetRunStep(threadId, runId, stepId, context);
            return Result.FromValue(RunStepObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run step.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStepAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Result> GetRunStepAsync(string threadId, string runId, string stepId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNullOrEmpty(stepId, nameof(stepId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunStep");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepRequest(threadId, runId, stepId, context);
                return Result.FromResponse(await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieves a run step.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetRunStep(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="threadId"> The ID of the thread to which the run and run step belongs. </param>
        /// <param name="runId"> The ID of the run to which the run step belongs. </param>
        /// <param name="stepId"> The ID of the run step to retrieve. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="threadId"/>, <paramref name="runId"/> or <paramref name="stepId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="MessageFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Result GetRunStep(string threadId, string runId, string stepId, RequestOptions context)
        {
            ClientUtilities.AssertNotNullOrEmpty(threadId, nameof(threadId));
            ClientUtilities.AssertNotNullOrEmpty(runId, nameof(runId));
            ClientUtilities.AssertNotNullOrEmpty(stepId, nameof(stepId));

            using var scope = ClientDiagnostics.CreateSpan("Runs.GetRunStep");
            scope.Start();
            try
            {
                using PipelineMessage message = CreateGetRunStepRequest(threadId, runId, stepId, context);
                return Result.FromResponse(_pipeline.ProcessMessage(message, context));
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal PipelineMessage CreateCreateThreadAndRunRequest(RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/runs", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCreateRunRequest(string threadId, RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateGetRunsRequest(string threadId, int? limit, string order, string after, string before, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetRunRequest(string threadId, string runId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateModifyRunRequest(string threadId, string runId, RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateCancelRunRequest(string threadId, string runId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            uri.AppendPath("/cancel", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateSubmitToolOuputsToRunRequest(string threadId, string runId, RequestBody content, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("POST");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            uri.AppendPath("/submit_tool_outputs", false);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            request.SetHeaderValue("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal PipelineMessage CreateGetRunStepsRequest(string threadId, string runId, int? limit, string order, string after, string before, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            uri.AppendPath("/steps", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        internal PipelineMessage CreateGetRunStepRequest(string threadId, string runId, string stepId, RequestOptions context)
        {
            var message = _pipeline.CreateMessage(context, ResponseErrorClassifier200);
            var request = message.Request;
            request.SetMethod("GET");
            var uri = new RequestUri();
            uri.Reset(_endpoint);
            uri.AppendPath("/threads/", false);
            uri.AppendPath(threadId, true);
            uri.AppendPath("/runs/", false);
            uri.AppendPath(runId, true);
            uri.AppendPath("/steps/", false);
            uri.AppendPath(stepId, true);
            request.Uri = uri.ToUri();
            request.SetHeaderValue("Accept", "application/json");
            return message;
        }

        private static RequestOptions DefaultRequestContext = new RequestOptions();
        internal static RequestOptions FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestOptions() { CancellationToken = cancellationToken };
        }

        private static ResponseErrorClassifier _responseErrorClassifier200;
        private static ResponseErrorClassifier ResponseErrorClassifier200 => _responseErrorClassifier200 ??= new StatusResponseClassifier(stackalloc ushort[] { 200 });
    }
}
